<?xml version="1.0" encoding="utf-8"?><CheatTable CheatEngineTableVersion="42"><CheatEntries><CheatEntry><ID>1</ID><Description>"Scrape Table from App Memory"</Description><VariableType>Auto Assembler Script</VariableType><AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local saveDialog = createSaveDialog(self) saveDialog.Title = "Save files as..." saveDialog.DefaultExt = ".CT" saveDialog.Filter = "Cheat Table|*" .. saveDialog.DefaultExt if saveDialog.execute() then SaveLocation = saveDialog.FileName else assert() end if not FRFAppLocation then local openDialog = createOpenDialog(self) openDialog.Title = "Open FRF App..." openDialog.DefaultExt = ".exe" openDialog.Filter = "Executable|*" .. openDialog.DefaultExt if openDialog.execute() then FRFAppLocation = openDialog.FileName else assert() end end CreateStringInputForm("FRFTableID", "Enter ID", "Enter Table/File ID:", true, false, nil, nil) if FRFAppLocation then GrabTableThread = createThread(function(Thread) GrabTableMain(Thread, 65535) end) end
[DISABLE]
GrabTableThread.terminate()
{$asm}</AssemblerScript></CheatEntry></CheatEntries><LuaScript>b64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" function GrabTableMain(Thread, loopCount) detachIfPossible() unpause() local startIndex = 0 print(formVariables.FRFTableID) if formVariables.FRFTableID and formVariables.FRFTableID ~= -1 then loopCount = tonumber(formVariables.FRFTableID) startIndex = tonumber(formVariables.FRFTableID) end for i = startIndex, loopCount do if Thread.Terminated then return end createProcess(FRFAppLocation, i .. " -start", false) debugProcess() pause() reinitializeSymbolhandler() local addr = nil if not process or process == "" then process = "FearlessRevolution.exe" end while (not process or process == "" or not getAddressSafe(process)) do sleep(100) if Thread.Terminated then return end end while (not addr or addr &lt;= 0x0 or not isAddrInModule(addr, process)) do if Thread.Terminated then return end unpause() print("Waiting...") sleep(750) pause() addr = AoBTools.ScanAoBTable( {{"03 00 00 00 * 01 00 00 00 E8 * * * * 89"}, {"90 48 * * E8 * * * * 90"}}, getAddressSafe(process), getAddressSafe(process) + getModuleSize(process) ) end print("Found b64 body finished decoding code: " .. NumberToHexString(addr)) local cheatTable = nil local timeout = 15000 debug_setBreakpoint(addr + 0x9) unpause() repeat if Thread.Terminated then return end unpause() while (not debug_isBroken()) do if timeout &lt;= 0 then print("Took too long. Skipping...") break end unpause() sleep(100) timeout = timeout - 100 if Thread.Terminated then return end end if timeout &lt;= 0 then break end pause() print("Process has broken.") local b64StrSize = readQword(RCX + 0x8) local b64Str = readString(RCX + 0x10, b64StrSize) local cheatTableBody = B64Decode(b64Str) local x = cheatTableBody:find("&gt;[\r\n]") if x then cheatTableBody = cheatTableBody:sub(x, string.len(cheatTableBody) - x) end if cheatTableBody and cheatTableBody:sub(0, 19) == "&gt;\r\n  &lt;CheatEntries&gt;" then cheatTable = "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\r\n&lt;CheatTable CheatEngineTableVersion=\"0\"" .. cheatTableBody end debug_continueFromBreakpoint(o_run) until (cheatTable and cheatTable:sub(0, 5) == "&lt;?xml") if (cheatTable and cheatTable:sub(0, 5) == "&lt;?xml" and SaveLocation) then local _,cheatTableClosing = cheatTable:find(".*&lt;CheatTable&gt;") if not cheatTableClosing or cheatTableClosing ~= string.len(cheatTable) then local _,luaScriptClosing = cheatTable:find(".*&lt;/LuaScript&gt;") if luaScriptClosing then print(luaScriptClosing) cheatTable = cheatTable:sub(0, luaScriptClosing) else local _,cheatEntiresClosing = cheatTable:find(".*&lt;/Comments&gt;") if cheatEntiresClosing then cheatTable = cheatTable:sub(0, cheatEntiresClosing) else local _,cheatEntiresClosing = cheatTable:find(".*&lt;/CheatEntries&gt;") if cheatEntiresClosing then cheatTable = cheatTable:sub(0, cheatEntiresClosing) end end end cheatTable = cheatTable .. "\r\n&lt;/CheatTable&gt;" end print("Saving file...") local f, e = io.open(SaveLocation:match("(.+)%..+$") .. "-" .. tostring(i) .. ".CT", "w+") lines = {} for s in cheatTable:gmatch("[^\r\n]+") do table.insert(lines, s) end for _, line in ipairs(lines) do if line ~= nil and line ~= "" then f:write(line, "\n") end end f:close() end detachIfPossible() unpause() ExitProcess() sleep(2500) end end function ExitProcess() autoAssemble([[
alloc(m,64)
createthread(m)
m:
push 0
call exitProcess
ret]]) end function B64Decode(data) data = string.gsub(data, "[^" .. b64Chars .. "=]", "") return (data:gsub( ".", function(x) if (x == "=") then return "" end local r, f = "", (b64Chars:find(x) - 1) for i = 6, 1, -1 do r = r .. (f % 2 ^ i - f % 2 ^ (i - 1) &gt; 0 and "1" or "0") end return r end ):gsub( "%d%d%d?%d?%d?%d?%d?%d?", function(x) if (#x ~= 8) then return "" end local c = 0 for i = 1, 8 do c = c + (x:sub(i, i) == "1" and 2 ^ (8 - i) or 0) end return string.char(c) end )) end --[[- AoB Tools ---]] AoBTools = {} AoBTools.AoBPointerType = {} AoBTools.AoBPointerType.NearAddress = 0x0 AoBTools.AoBPointerType.FarAddress = 0x1 AoBTools.AoBPointerType.CloseJump = 0x2 AoBTools.AoBPointerType.FarJump = 0x3 AoBTools.AoBPointerType.Offset = 0x4 function AoBTools.ScanAoBTable(aobTable, address, range) local addr = address for i, tbl in ipairs(aobTable) do addr = AoBTools.AoBScanRegion(tbl[1], addr, range) if addr == 0x0 then break end if tbl[2] then addr = addr + tbl[2] end if tbl[3] then addr = AoBTools.ReadAoBPointer(addr, tbl[3][1], tbl[3][2], tbl[3][3]) end end return addr end function AoBTools.ReadAoBPointer(addr, pType, offSize, signed) if not offSize then offSize = 0x1 end if not signed then signed = false end if pType == AoBTools.AoBPointerType.NearAddress or pType == AoBTools.AoBPointerType.FarJump then return addr + readIntegerSigned(addr) + 0x4 elseif pType == AoBTools.AoBPointerType.FarAddress then return readPointer(addr) elseif pType == AoBTools.AoBPointerType.CloseJump then return addr + readByteSigned(addr) + 0x1 elseif pType == AoBTools.AoBPointerType.Offset then if offSize == 0x1 then return signed and readByteSigned(addr) or readBytes(addr, offSize, false) elseif offSize == 0x2 then return signed and readSmallIntegerSigned(addr) or readSmallInteger(addr) elseif offSize == 0x4 then return signed and readIntegerSigned(addr) or readInteger(addr) elseif offSize == 0x8 then return signed and readQwordSigned(addr) or readQword(addr) elseif offsize == -1 then return readPointer(addr) else return readBytes(addr, offSize, true) end end end function AoBTools.AoBScanModule(bytes, moduleName) if not moduleName then moduleName = process end return AoBScanRegion(bytes, getAddressSafe(moduleName), getModuleSize(moduleName)) end function AoBTools.AoBScanRegion(signature, startAddress, endAddress, aobSignaturePrivileges, alignmentType, alignmentParam) if not signature or not startAddress or not endAddress then return end index = index or 1 local ms = createMemScan() if type(signature) == 'table' then local sig = '' for i, byte in ipairs(signature) do sig = sig..string.format('%02X', byte) end signature = sig end ms.firstScan(soExactValue, vtByteArray, nil, signature, nil, startAddress, endAddress, aobSignaturePrivileges, alignmentType, alignmentParam, true, true, false, false) ms.waitTillDone() local results = createFoundList(ms) results.initialize() ms.destroy() local result = 0x0 if results.Count &gt; 0x0 then result = tonumber(results[0], 0x10) print(result) end return result end --[[- General Functions ---]] function isAddrInModule(addr, moduleName) local moduleAddr = getAddressSafe(moduleName) return (addr &gt;= moduleAddr and addr &lt; (moduleAddr + getModuleSize(moduleName))) end function readQwordSigned(addr) local val = readQword(addr) return readSignedValue(val, 0x8000000000000000) end function readIntegerSigned(addr) local val = readInteger(addr) return readSignedValue(val, 0x80000000) end function readSmallIntegerSigned(addr) local val = readSmallInteger(addr) return readSignedValue(val, 0x8000) end function readByteSigned(addr) local val = readBytes(addr, 1, false) return readSignedValue(val, 0x80) end function readSignedValue(val, valSize) local sign = bAnd(val, valSize) return sign == 0 and val or val - (bShl(valSize, 0x1)) end function NumberToHexString(num) return string.format("%X", num) end --[[- Form Tools ---]] function CreateStringInputForm(varName, formName, labelText, numbersOnly, isHex, width, height, func) local form = CreateBaseForm(formName, labelText, width, height) formVariables[varName] = nil local text_box = createEdit(form) text_box.setTop(form.Height - 60) text_box.Width = form.Width - 20 text_box.anchorSideLeft.control = form text_box.anchorSideLeft.side = asrCenter if numbersOnly == true then text_box.Text = 0 end local OK_Button = createButton(form) OK_Button.setTop(form.Height - 30) OK_Button.Width = form.Width - 20 OK_Button.Caption = "OK" OK_Button.anchorSideLeft.control = form OK_Button.anchorSideLeft.side = asrCenter local finishFunc = function() if numbersOnly == true then local num = tonumber(text_box.Text, isHex and 0x10 or 10) if num then formVariables[varName] = num else formVariables[varName] = 0 end else formVariables[varName] = text_box.Text end if func then func(formVariables[varName], varName) end form.close() end text_box.onKeyDown = function(_, key) if key == 0xD then finishFunc() end end OK_Button.onClick = finishFunc form.showModal() end function CreateDropdownForm(varName, itemArray, formName, labelText, width, height, func) local form = CreateBaseForm(formName, labelText, width, height) formVariables[varName] = nil local slot_box = createComboBox(form) slot_box.setTop(form.Height - 30) slot_box.Width = form.Width - 20 slot_box.anchorSideLeft.control = form slot_box.anchorSideLeft.side = asrCenter for _, item in ipairs(itemArray) do slot_box.items.add(item) end slot_box.onChange = function() formVariables[varName] = slot_box.ItemIndex if func then func(formVariables[varName], varName, itemArray[hexItemIndex]) end form.close() end form.showModal() end function CreateBaseForm(formName, labelText, width, height) if not width then width = 180 end if not height then height = 80 end if not formVariables then formVariables = {} end local form = createForm(false) m = getmetatable(form) m.__autodestroy = true local label = createLabel(form) form.centerScreen() form.Width = width form.Height = height label.anchorSideLeft.control = form label.anchorSideLeft.side = asrCenter label.Width = form.Width - 20 control_setCaption(form, formName) control_setCaption(label, labelText) return form end</LuaScript><Signature><SignedHash HashSize="132">0j=(X7MS_Tf3EcLEs0Q,npj#43w/zq)@ypTh=spFcl*H;@jCoHifK/DlW;LyO,(MFv2[!zF/C!k[Ck#xLTLdZ6nu6Kjog.^,r{W+*uP;Bm}!Zw5=olxb,D:/d_7^%ll*4}:!@HqxIeW)7q98cgo.03A^Jw0-:RLeT,u*#</SignedHash><PublicKey Size="297">3.,NCM]dpycVTlNXk}I]i}s?vMMG0HLI3}(0I#1E+t$1ysg(c=MHOh=ex#Aaz!9:}l5tGL(6tdLGN;GoH%LSK6!og4BPU}eT(KZqU*aN1GP*g3CClGv*;.4q[[t%^[GrJWaC_rJ#+!6IgLz,{$:9lJ?yXndmmIN+nCSjr+QdGP_AGL6[VcYy@d8?=fuX2tc$_m^hK_aF0E7Sl00I8Ea$2BtoIwedcmRP8g$yjVv=483B/ODtHg-^/M1d1JeDFeCP5D[K8JqxBSbm7=5AG2i+/SBUwbTqxn?%zT*@(KC7t@F@/SsEG,,v!qZ;y$@xA#:SpBxu!Z@]0Rcj,()y)MVh-RGsZ$@##Tb.Z;TD?lvH^?Xr.!25CwbN</PublicKey></Signature></CheatTable>